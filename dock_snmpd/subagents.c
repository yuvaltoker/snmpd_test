/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.int_watch.conf,v 5.0 2002/04/20 07:30:13 hardaker Exp $
 * hey.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "subagents.h"


/*---------------------------------------------------------------------------------------------------*/

/* Make sure those next includes files are at this path, and that you've got the files */

#include "hiredis/hiredis.h"
#include "hiredis/async.h"
#include "hiredis/adapters/libevent.h"

/*---------------------------------------------------------------------------------------------------*/
//Redis connection
static redisContext *c;
redisContext **con = &c;

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/* Every commented "DEBUGMSGTL" had exchanged with snmp_log, it's a way of debugging */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/


void connectToRedis(void)
{
    const char *hostname = "redis_db"; // Should be the name of the container where redis at
    int port = 6379; // Redis interacts at port 6379
    struct timeval timeout = { 1, 50000 }; // 1.5 seconds
    c = redisConnectWithTimeout(hostname, port, timeout); //Calling the connection function @hiredis/hiredis.c

    snmp_log(LOG_ERR, "Connecting to redis...\n");
    // Didn't connect to redis
    if(c == NULL || c->err)
    {
     	if(c) // Which means c->err
	{
            snmp_log(LOG_ERR, "connection error: %s\n", c->errstr);
            //DEBUGMSGTL(("batteryObject", "Connection error: %s\n", c->errstr));
            redisFree(c);
        }
        else // Which means c ==NULL
        {
            snmp_log(LOG_ERR, "connection error: can't allocate redis context\n");
            //DEBUGMSGTL(("batteryObject", "Connection error: can't allocate redis context\n"));
        }
    }
    else // Connected successfully
    {
        snmp_log(LOG_ERR, "redis connection successful\n");
     	//DEBUGMSGTL(("batteryObject", "Connection Successful\n"));
    }
}


void shutdownRedis(void)
{
    redisFree(c);
}

/*
 * the variable we want to tie an OID to.  The agent will handle all
 * GET and SET requests to this variable changing it's value as needed.
 */

static int batteryObject_value = 4; // The first value of the mib. (1-100)
static int channelObject_value = 1; // The first value of the mib. (1-12)
enum object_mode { battery_mode, channel_mode};
/** Initializes the sub_agent_test module */
void
init_subagents(void)
{
//                                      The whole oid as in the MY-TUTORIAL-MIB.txt, without the .0 at the end.
//                                                                         |
    static oid batteryObject_oid[] = { 1, 3, 6, 1, 4, 1, 8072, 2, 4, 1, 1, 4 };

    static oid channelObject_oid[] = { 1, 3, 6, 1, 4, 1, 8072, 2, 4, 1, 1, 5 };

    //DEBUGMSGTL(("batteryAgentSubagentObject", "Initializing\n"));

    // Setting the battery value in redis for the first time
    SET_objects_redis(battery_mode);

    // Setting the channel value in redis for the first time
    SET_objects_redis(channel_mode);

    // Registering the mib-handler, thus making the subagent able to maintain the battery mib
    netsnmp_register_handler(
        netsnmp_create_handler_registration("batteryObject", handle_batteryObject,
                                            batteryObject_oid, OID_LENGTH(batteryObject_oid),
                                            HANDLER_CAN_RWRITE
        ));

    // Registering the mib-handler, thus making the subagent able to maintain the channel mib
    netsnmp_register_handler(
        netsnmp_create_handler_registration("channelObject", handle_channelObject,
                                            channelObject_oid, OID_LENGTH(channelObject_oid),
                                            HANDLER_CAN_RWRITE
        ));

}

int
handle_batteryObject(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    int ret;
    /* we are never called for a GETNEXT if it's registered as a
       "instance", as it's "megically" handled for us. */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
     	case MODE_GET: // snmpget
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &batteryObject_value,
                                     sizeof(batteryObject_value));
            snmp_log(LOG_ERR, "mode (%d) in handle_batteryObject\n", reqinfo->mode);
            break;

        case MODE_SET_RESERVE1:
            snmp_log(LOG_ERR, "mode (%d) (reserve1) in handle_batteryObject\n", reqinfo->mode);
            break;

        case MODE_SET_RESERVE2:
            snmp_log(LOG_ERR, "mode (%d) (reserve2) in handle_batteryObject\n", reqinfo->mode);
            break;

        case MODE_SET_FREE:
            snmp_log(LOG_ERR, "mode (%d) (set-free) in handle_batteryObject\n", reqinfo->mode);
            break;

        case MODE_SET_COMMIT:
            snmp_log(LOG_ERR, "mode (%d) (commit) in handle_batteryObject\n", reqinfo->mode);
            break;

        case MODE_SET_UNDO:
             snmp_log(LOG_ERR, "mode (%d) (set-undo) in handle_batteryObject\n", reqinfo->mode);
             break;

        case MODE_SET_ACTION: // snmpset
            /* perform the value change here */

            snmp_log(LOG_ERR, "mode (%d) (set-action) in handle_batteryObject\n", reqinfo->mode);
            if(requests->requestvb->type != ASN_INTEGER) // If it's not an integer
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_WRONGTYPE;
            }

            if(*requests->requestvb->val.integer < 0 || *requests->requestvb->val.integer > 100) // If battery is not between 0-100
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_WRONGVALUE;
            }
            batteryObject_value = *requests->requestvb->val.integer; // Setting batteryObject_value as an preparation for the next function
            SET_objects_redis(battery_mode); // Calling the fucntion which takes care of redis' setting
            break;

        default:
             /* we should never get here, so this is a really bad error */
             snmp_log(LOG_ERR, "unknown mode (%d) in handle_batteryObject\n", reqinfo->mode);
             return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_channelObject(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
    int ret;
    /* we are never called for a GETNEXT if it's registered as a
       "instance", as it's "megically" handled for us. */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch(reqinfo->mode)
    {
     	case MODE_GET: // snmpget
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &channelObject_value,
                                     sizeof(channelObject_value));
            snmp_log(LOG_ERR, "mode (%d) in handle_channelObject\n", reqinfo->mode);
            break;

        case MODE_SET_RESERVE1:
            snmp_log(LOG_ERR, "mode (%d) (reserve1) in handle_channelObject\n", reqinfo->mode);
            break;

        case MODE_SET_RESERVE2:
            snmp_log(LOG_ERR, "mode (%d) (reserve2) in handle_channelObject\n", reqinfo->mode);
            break;

        case MODE_SET_FREE:
            snmp_log(LOG_ERR, "mode (%d) (set-free) in handle_channelObject\n", reqinfo->mode);
            break;

        case MODE_SET_COMMIT:
            snmp_log(LOG_ERR, "mode (%d) (commit) in handle_channelObject\n", reqinfo->mode);
            break;

        case MODE_SET_UNDO:
             snmp_log(LOG_ERR, "mode (%d) (set-undo) in handle_channelObject\n", reqinfo->mode);
             break;

        case MODE_SET_ACTION: // snmpset
            /* perform the value change here */

            snmp_log(LOG_ERR, "mode (%d) (set-action) in handle_channelObject\n", reqinfo->mode);
            if(requests->requestvb->type != ASN_INTEGER) // If it's not an integer
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGTYPE);
                return SNMP_ERR_WRONGTYPE;
            }

            if(*requests->requestvb->val.integer < 0 || *requests->requestvb->val.integer > 12) // If channel is not between 0-12
            {
             	netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
                return SNMP_ERR_WRONGVALUE;
            }
            channelObject_value = *requests->requestvb->val.integer; // Setting channelObject_value as an preparation for the next function
            SET_objects_redis(channel_mode); // Calling the fucntion which takes care of redis' setting
            break;

        default:
             /* we should never get here, so this is a really bad error */
             snmp_log(LOG_ERR, "unknown mode (%d) in handle_channelObject\n", reqinfo->mode);
             return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


//-----------------------------------------------------------------------------------//
//make the get and set functions smart, send them which mib you want to change or get// 
//-----------------------------------------------------------------------------------//

void GET_objects_redis(int mode) // Manages snmpget
{   // mode: 0 - battery
    //       1 - channel  
    //GET LOCAL MANAGE INFO

    redisReply *reply;
    if(mode == battery_mode)
    {
        // Normal redis get command, getting batteryObjectField from redis server
        reply = (redisReply*)(redisCommand(c, "GET batteryObjectField"));
    }
    else
    {
        // Normal redis get command, getting channelObjectField from redis server
        reply = (redisReply*)(redisCommand(c, "GET channelObjectField"));
    }

    if(reply->type == REDIS_REPLY_ERROR)
    {
     	snmp_log(LOG_ERR, "GET error: %s\n", reply->str);
        //DEBUGSGTL(("batteryObject", "GET error: %s\n", reply->str));
    }
    else
    {
     	if(reply->str == NULL)
        {
            if(mode == battery_mode)
            { memset(&batteryObject_value, 0, sizeof(batteryObject_value)); }
            else
            { memset(&channelObject_value, 0, sizeof(channelObject_value)); }
        }
	else
	{
            if(mode == battery_mode)
            { memmove(batteryObject_value, reply->str, sizeof(batteryObject_value)); }
            else
            { memmove(channelObject_value, reply->str, sizeof(channelObject_value)); }
        }
    }
    freeReplyObject(reply);
}

void SET_objects_redis(int mode)
{
    redisReply *reply;
    
    if(mode == battery_mode)
    {
        // Normal redis set command, setting batteryObjectField from redis server
        reply = (redisReply*)(redisCommand(*con, "SET batteryObjectField %d", batteryObject_value));
    }
    else
    {
        // Normal redis set command, setting channelObjectField from redis server
        reply = (redisReply*)(redisCommand(*con, "SET channelObjectField %d", channelObject_value));
    }

    if(reply->type == REDIS_REPLY_ERROR)
    {
        snmp_log(LOG_ERR, "SET error: %s\n", reply->str);
     	//DEBUGSGTL(("batteryObject", "SET error: %s\n", reply->str));
    }
    freeReplyObject(reply);
}

